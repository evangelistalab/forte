{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "70dc7132-9993-4982-b620-af8ae7492591",
   "metadata": {},
   "source": [
    "# Forte Python API Tutorial (NEW)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "18cd7d81-0b5e-4d06-aa4b-fe810f663115",
   "metadata": {},
   "source": [
    "Forte's new python API allows the user to express a calculation as a computational graph.\n",
    "Nodes on this graph do one of the following\n",
    "- Provide inputs\n",
    "- Take inputs from other nodes and perform a computational task"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7e1b2410-0080-4dc3-a634-daacca9c5d0a",
   "metadata": {},
   "source": [
    "## Creating the input node\n",
    "\n",
    "The starting point for a Forte computation is an input object (`Input`). The input can be created via a factory function (`forte.solvers.solver_factory`)\n",
    "\n",
    "```python\n",
    "    from forte.solvers import solver_factory\n",
    "    \n",
    "    # define the molecular geometry (H2, r = 1 Å)\n",
    "    zmat = \"\"\"\n",
    "    H\n",
    "    H 1 1.0\n",
    "    \"\"\"\n",
    "    \n",
    "    # create the input node using the zmat geometry and the cc-pVDZ basis set\n",
    "    input = input_factory(molecule=zmat, basis='cc-pVDZ')\n",
    "```\n",
    "The object returned by `solver_factory` (`input`) is an input node that contains a `MolecularModel` attribute responsible for generating the Hamiltonian of this molecule/basis set combination.\n",
    "The `input` object can now be passed to a `Solver` node that will perform a computation."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "821d0545-3bf5-4c11-a138-bb73c2965596",
   "metadata": {},
   "source": [
    "## Hartree–Fock theory\n",
    "\n",
    "To run a Hartree–Fock (HF) computation on the molecule defined above the user has to do the following:\n",
    "\n",
    "  1. Specify the electronic state\n",
    "  2. Create a Hartree–Fock solver object\n",
    "  3. Call the `run()` function\n",
    "\n",
    "Here is an example that shows the full input for a HF computation:\n",
    "```python\n",
    "from forte.solvers import solver_factory, HF\n",
    "\n",
    "xyz = \"\"\"\n",
    "H 0.0 0.0 0.0\n",
    "H 0.0 0.0 1.0\n",
    "\"\"\"\n",
    "input = input_factory(molecule=xyz, basis='cc-pVDZ')\n",
    "\n",
    "# 1. singlet Ag state of H2 (neutral)\n",
    "state = input.state(charge=0, multiplicity=1, sym='ag') \n",
    "\n",
    "# 2. create the HF object\n",
    "hf = HF(input, state=state)  \n",
    "\n",
    "# 3. run the computation\n",
    "hf.run()  \n",
    "```\n",
    "The output of this computation can be found in the `output.dat` file.\n",
    "However, the results of this computation are also stored in the HF object.\n",
    "For example, the HF energy can be accessed via `hf.value('hf energy')`.\n",
    "\n",
    "To understand what happens when we setup this computation it is convenient to visualize it in the following way:\n",
    "\n",
    "<center>\n",
    "<img src=\"../source/img/api_intro-01.png\" alt=\"computation graph\" width=\"300\">\n",
    "</center>\n",
    "\n",
    "This image represents the computation as a graph, where each step (setting up the input, running the HF computation) method is a node connected to the next step in a computation.\n",
    "When we invoke the method `run()` on the Hartree–Fock object, the computation is executed, starting from the HF object backwards."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "435ea455-ca6c-4f8b-8435-5762ef055352",
   "metadata": {},
   "source": [
    "## Active space solvers: Full Configuration Interation (FCI), Complete Active Space CI (CASCI), and more\n",
    "\n",
    "Forte implements several solvers that diagonalize the Hamiltonian in a (small) space of orbitals, including FCI, selected CI methods, and generalized active space (GAS).\n",
    "To perform one of these computations just pass an object that can provide molecular orbitals to an `ActiveSpaceSolver` object. For example, we can perform a CASCI computation on the same molecule as above by passing the `HF` node to an `ActiveSpaceSolver` node, as show in the following image\n",
    "<center>\n",
    "<img src=\"../source/img/api_intro-02.png\" alt=\"computation graph\" width=\"492\">\n",
    "</center>\n",
    "\n",
    "The following input performs a CASCI computation on H$_2$ using RHF orbitals\n",
    "\n",
    "```python\n",
    "from forte.solvers import solver_factory, HF, ActiveSpaceSolver\n",
    "\n",
    "xyz = \"\"\"\n",
    "H 0.0 0.0 0.0\n",
    "H 0.0 0.0 1.0\n",
    "\"\"\"\n",
    "input = input_factory(molecule=xyz, basis='cc-pVDZ')\n",
    "\n",
    "state = input.state(charge=0, multiplicity=1, sym='ag') \n",
    "\n",
    "# create the HF object\n",
    "hf = HF(input, state=state)  \n",
    "\n",
    "# specify the active space\n",
    "# we pass an array with the number of active MOs per irrep based on Cotton ordering\n",
    "# this selects an active space with one MO from irrep 0 (Ag) and one from irrep 5 (B1u)\n",
    "mo_spaces = input.mo_spaces(active=[1, 0, 0, 0, 0, 1, 0, 0])\n",
    "\n",
    "# initialize a FCI solver and pass the HF object, the target electronic state, and the MO space information\n",
    "fci = ActiveSpaceSolver(hf, type='FCI', states=state, mo_spaces=mo_spaces)\n",
    "\n",
    "# call run() on the FCI node\n",
    "fci.run()  \n",
    "```\n",
    "The CASCI energy can be accessed via the `value` function on the FCI object. In this case it returns a vector containing the energy of all the states computed:\n",
    "```python\n",
    "fci.value('active space energy')[state] -> [-1.1083377195359851]\n",
    "```\n",
    "\n",
    "To compute two $^1 A_{g}$ states we can simply pass a dictionary that maps states to number of desired solutions\n",
    "```python\n",
    "fci = ActiveSpaceSolver(hf, type='FCI', states={state : 2}, mo_spaces=mo_spaces)\n",
    "```\n",
    "The energy of the two $^1 A_{g}$ states can still be retrieved with the `value` function:\n",
    "```python\n",
    "fci.value('active space energy')[state] -> [-1.1083377195359851, -0.2591786932627466]\n",
    "```\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8e9a09b6-36c0-453a-8f92-9f3ae6c08103",
   "metadata": {},
   "source": [
    "## Multiconfigurational SCF (MCSCF)\n",
    "\n",
    "To run an MCSCF computation in which we simultaneously optimize the orbitals and active space wave function, we use the MCSCF class.\n",
    "This class requires as an input node an `ActiveSpaceSolver` object, and therefore, can be combine with any of the solvers implemented in Forte.\n",
    "The following shows a scheme of a typical CASCI computation, using Hartree–Fock orbitals as initial guess for the MCSCF computation\n",
    "<center>\n",
    "<img src=\"../source/img/api_intro-03.png\" alt=\"computation graph\" style=\"width: 636px;\"/>\n",
    "</center>\n",
    "\n",
    "```python\n",
    "from forte.solvers import HF, ActiveSpaceSolver, MCSCF, solver_factory\n",
    "\n",
    "xyz = \"\"\"\n",
    "H 0.0 0.0 0.0\n",
    "H 0.0 0.0 1.0\n",
    "\"\"\"\n",
    "\n",
    "input = input_factory(molecule=xyz, basis='cc-pVDZ')\n",
    "state = input.state(charge=0, multiplicity=1, sym='ag')\n",
    "mo_spaces = input.mo_spaces(active=[1, 0, 0, 0, 0, 1, 0, 0])\n",
    "\n",
    "hf = HF(input, state=state)\n",
    "fci = ActiveSpaceSolver(hf, type='FCI', states=state, mo_spaces=mo_spaces)\n",
    "mcscf = MCSCF(fci)  # <- use information in fci to get active space, etc.\n",
    "mcscf.run()\n",
    "\n",
    "# results are stored in mcscf.value('mcscf energy')[state]\n",
    "```"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
